package declarative_test

import (
	"errors"
	"os"
	"testing"

	"github.com/kyma-project/module-manager/operator/pkg/declarative"

	"github.com/go-logr/zerologr"
	"github.com/kyma-project/module-manager/operator/pkg/types"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

func TestGet(t *testing.T) {
	t.Parallel()
	zl := zerolog.New(os.Stderr)
	zl = zl.With().Caller().Timestamp().Logger()
	logger := zerologr.New(&zl)

	type test struct {
		testName                 string
		name                     string
		namespace                string
		object                   types.BaseCustomObject
		expectedInstallationSpec types.InstallationSpec
		expectedErr              error
	}

	tests := []test{
		{
			testName:  "Resolve object with valid values",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartPath:   "path/to/chart",
					ReleaseName: "test-release",
					ChartFlags:  types.ChartFlags{},
				},
			},
			expectedInstallationSpec: types.InstallationSpec{
				ChartPath:   "path/to/chart",
				ReleaseName: "test-release",
				ChartFlags:  types.ChartFlags{},
			},
			expectedErr: nil,
		},
		{
			testName:  "`chartPath` not given",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartFlags: types.ChartFlags{},
				},
			},
			expectedInstallationSpec: types.InstallationSpec{},
			expectedErr: &declarative.ResolveError{
				ObjectName: "default/testCR",
				Err:        errors.New(declarative.ErrMsgMandatory),
			},
		},
		{
			testName:  "Resolve object with minimal valid input",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartPath: "path/to/chart",
				},
			},
			expectedInstallationSpec: types.InstallationSpec{ChartPath: "path/to/chart", ReleaseName: ""},
			expectedErr:              nil,
		},
	}

	for _, tc := range tests {
		testCase := tc
		resolver := declarative.DefaultManifestResolver{}
		t.Run(testCase.testName, func(t *testing.T) {
			t.Parallel()
			testCase.object.SetName(testCase.name)
			testCase.object.SetNamespace(testCase.namespace)
			installationSpec, err := resolver.Get(testCase.object, logger)
			assert.Equal(t, testCase.expectedInstallationSpec, installationSpec)
			assert.Equal(t, testCase.expectedErr, err)
		})
	}
}

// TestCRD implements the BaseCustomObject and can be used for easy testing.
type TestCRD struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   types.InstallationSpec `json:"spec,omitempty"`
	Status types.Status           `json:"status,omitempty"`
}

func (s *TestCRD) GetStatus() types.Status {
	// return s.Status
	return types.Status{}
}

func (s *TestCRD) SetStatus(status types.Status) {
}

func (s *TestCRD) ComponentName() string {
	return "test-component-name"
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (s *TestCRD) DeepCopyInto(out *TestCRD) {
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestCRD.
func (s *TestCRD) DeepCopy() *TestCRD {
	return nil
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (s *TestCRD) DeepCopyObject() runtime.Object {
	return nil
}
